#!/usr/bin/env python
from dropbox import client, rest, session
import webbrowser
import urllib
import sys

import os

import getpass
from keystoneclient.v3 import client as keystone_client
from urlparse import urlparse

from contextlib import closing # close URLConnection with 'with'

from config import Config
import argparse
import json
import time

import re

import pkg_resources

from multiprocessing import Pool

fourGigSize = 4*1024*1024*1024-1

def get_client(namespace):
    if(namespace.user):
        user = namespace.user
        if(namespace.password):
            password = namespace.password
        else:
            password = getpass.getpass('Password:')
    elif (os.environ["SS_USER"]):
        user = os.environ["SS_USER"]
        password = os.environ["SS_KEY"]
    else:
        parser.error('user parameter is required')

    if (namespace.keystone_url):
        keystone_url = namespace.keystone_url
    elif (os.environ["KEYSTONE_URL"]):
        keystone_url = os.environ["KEYSTONE_URL"]
    else:
        parser.error('keystone_url parameter is required')

    keystone = keystone_client.Client(username=user, password=password, tenant_name=user, auth_url=keystone_url)
    token = keystone.session.get_token()

    scidrive_url = keystone.auth_ref.service_catalog.get_urls(service_type='fileshare', endpoint_type='internal')
    if(not scidrive_url):
        parser.error('not found scidrive URL in catalog')

    sess = session.KeystoneSession(token, server="".join([urlparse(scidrive_url[0]).netloc, urlparse(scidrive_url[0]).path]))
    return client.DropboxClient(sess)

def make_upload_action():
    class UploadAction(argparse.Action):
        def __call__(self, parser, namespace, f, option_string=None):
            for f_ in f:
                if os.path.isdir(f_):
                    for root, subFolders, files in os.walk(f_):
                        for folder in subFolders:
                            print "Creating subdirectory %s" % os.path.join(namespace.folder, root, folder)
                            client.file_create_folder(os.path.join(namespace.folder, root, folder))

                        # Translates params to list of params to call in parallel
                        def fileToParams(filename):
                            filePath = os.path.join(root, filename)
                            return (filePath, client, os.path.join(namespace.folder, root), namespace.verbose, namespace.chunk_size)

                        filesJobs = map(fileToParams, files)
                        pool = Pool(processes=namespace.proc)
                        pool.map(uploadFilePar, filesJobs)

                elif os.path.isfile(f_):
                    print "Uploading %s" % os.path.join(namespace.folder, f_)
                    uploadFile(f_, client, namespace.folder, namespace.verbose, namespace.chunk_size)
                else:
                    print f_,"not found"
    return UploadAction     

def uploadFilePar(args):
    print args
    uploadFile(*args)

def uploadFile(f, client, folder, verbose, chunk_size):
    client = get_client(token)
    print "Uploading %s" % f
    if verbose:
        progress = Progress()
    else:
        progress = None

    with open(f, 'r') as f_:
        size = os.path.getsize(f_.name)

        if size > fourGigSize or chunk_size:
            if verbose:
                print "uploading chunked\n"

            if chunk_size:
                if chunk_size > 4*1024:
                    raise ValueError("Chunk size can't exceed 4 GB. Current size is: %i MB" % chunk_size)
                chunk_size = chunk_size*1024*1024
            else:
                chunk_size = fourGigSize

            uploader = client.get_chunked_uploader(f_, size, progress=progress)
            upload = uploader.upload_chunked(chunk_size = chunk_size)
            uploader.finish(os.path.join(folder,os.path.basename(f_.name)))
            if verbose:
                print "uploaded chunked\n"
        else:
            print size," ",fourGigSize
            response = client.put_file(os.path.join(folder,os.path.basename(f_.name)), f_, True, progress=progress)
            if verbose:
                print "uploaded:\n", json.dumps(response, sort_keys=True, indent=4)

def make_test_action():
    class TestUploadAction(argparse.Action):
        def __call__(self, parser, namespace, f, option_string=None):

                print 'self ',self, '\n'
                print 'parser', parser, '\n'
                print 'namespace', namespace, '\n'
                print 'f', f, '\n'
                print 'opt_str', option_string, '\n'
    return TestUploadAction     


def make_userinfo_action():
    class UserInfoAction(argparse.Action):
        def __call__(self, parser, namespace, values, option_string=None):
            client = get_client(namespace)
            print "linked account:\n", json.dumps(client.account_info(), sort_keys=True, indent=4)
    return UserInfoAction       

def make_metadata_action():
    class MetadataAction(argparse.Action):
        def __call__(self, parser, namespace, f, option_string=None):
            client = get_client(namespace)
            response = client.metadata(f, namespace.list, include_deleted=namespace.include_deleted)
            print json.dumps(response, sort_keys=True, indent=4)
    return MetadataAction

def make_list_action():
    class MetadataAction(argparse.Action):
        def __call__(self, parser, namespace, f, option_string=None):
                response = get_client(namespace).metadata(f, True, include_deleted=namespace.include_deleted)
                for record in response['contents']:
                    print record['path']
    return MetadataAction

def make_delete_action():
    class DeleteAction(argparse.Action):
        def __call__(self, parser, namespace, f, option_string=None):
            for f_ in f:
                client = get_client(namespace)
                response = client.file_delete(f_)
                print json.dumps(response, sort_keys=True, indent=4)
    return DeleteAction

def make_download_action():
    class DownloadAction(argparse.Action):
        def __call__(self, parser, namespace, f, option_string=None):
            client = get_client(namespace)
            with closing(client.get_file(f)) as response:
                filename = re.findall(r'\bfilename=(.+)', response.getheader('content-disposition'))
                if namespace.output:
                    if len(filename) > 0:
                        with open(os.path.join(namespace.output, filename[0]), 'wb') as fb:
                            CHUNK = 16 * 1024
                            for chunk in iter(lambda: response.read(CHUNK), ''):
                                if not chunk: break
                                fb.write(chunk)
                    else:
                        raise ValueError("No filename in reply")
                else:
                    CHUNK = 16 * 1024
                    for chunk in iter(lambda: response.read(CHUNK), ''):
                        if not chunk: break
                        sys.stdout.write(chunk)
    return DownloadAction


class Progress(object):
    def __init__(self):
        self._seen = 0.0
        self._time = 0

    def update(self, total, size, name):
        if self._time == 0:
            self._time = int(time.time())
        self._seen += size
        pct = (self._seen / total) * 100.0

        __time = (int(time.time()) - self._time)
        __speed = self._seen/__time/1024.0/1024.0 if __time != 0 else 0
        __eta = total/(__speed*1024*1024)-__time if __time != 0 else 0
        
        sys.stdout.write('\r%s progress: %.2f%%, %i sec, %.2f MB/s, ETA: %i sec' % (name, pct, __time, __speed, __eta))
        sys.stdout.flush()

    def finish(self):
        sys.stdout.write('\r\n')
        sys.stdout.flush()


def dir(dirname):
    """Checks if a path is an actual directory"""
    if not os.path.isdir(dirname):
        msg = "{0} is not a directory".format(dirname)
        raise argparse.ArgumentTypeError(msg)
    else:
        return dirname

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Upload data to SciDrive')

    subparsers = parser.add_subparsers(help='commands')

    parser.add_argument('-v', '--verbose', help="Verbose output", action='store_true')
    parser.add_argument('-u', '--user', help="Use username from command line for obtaining token")
    parser.add_argument('-k', '--keystone_url', help="Keystone URL")
    parser.add_argument('-p', '--password', help="Use password from command line for obtaining token (if ommited, will be asked safely)")

    # Upload command
    upload_parser = subparsers.add_parser('upload', help='Upload file(s)')
    upload_parser.add_argument('-c', '--chunk-size', help='Chunk size', type=int)
    upload_parser.add_argument('-a', '--append', help='Upload only new files', default=True)
    upload_parser.add_argument('-p', '--proc', help='Number of parallel processes', default=6, type=int)
    upload_parser.add_argument('folder', help='Destination folder')
    upload_parser.add_argument('path', nargs='+', help='File or folder path', 
        action=make_upload_action())

    # User info command
    info_parser = subparsers.add_parser('info', help='User info')
    info_parser.add_argument('info', help="User info", nargs=0, action=make_userinfo_action())

    # Test command
    test_parser = subparsers.add_parser('test', help='Test')
    test_parser.add_argument('folder', help='Destination folder')
    test_parser.add_argument('path', nargs='+', help='File or folder path', type=argparse.FileType('r'), 
        action=make_test_action())

    # Download command
    download_parser = subparsers.add_parser('download', help='Download file contents (folder will be downloaded as .tar archive)')
    download_parser.add_argument('-o', '--output', type=dir, help='Create file in local folder')
    download_parser.add_argument('path', help='Remote path', action=make_download_action())

    # Delete command
    delete_parser = subparsers.add_parser('delete', help='Delete')
    delete_parser.add_argument('path', nargs='+', help='Remote file or folder path', action=make_delete_action())

    # metadata command
    metadata_parser = subparsers.add_parser('meta', help='File metadata')
    metadata_parser.add_argument('path', help='Remote file path', default='/', nargs='?', action=make_metadata_action())
    metadata_parser.add_argument('-l', '--list', help='List folder contents', action='store_true', default=False)
    metadata_parser.add_argument('-d', '--include-deleted', help='Include deleted files', action='store_true', default=False)

    # list command
    list_parser = subparsers.add_parser('ls', help='List contents')
    list_parser.add_argument('path', help='Remote folder path', default='/', nargs='?', action=make_list_action())
    list_parser.add_argument('-d', '--include-deleted', help='Include deleted files', action='store_true', default=False)

    args = parser.parse_args()
